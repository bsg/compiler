struct A {
    a: u32;
    b: u8;
    c: u32;
}

struct B {
    inner: A;
}

impl A {
    fn get_static() -> u32 {
        return 100;
    }

    fn get_a(self: Self) -> u32 {
        return self.a;
    }

    fn get_a_by_ref(self: &Self) -> u32 {
        return (*self).a;
    }
}


fn add(a: u32, b: u32) -> u32 {
    return a + b;
}

fn add_by_ref(a: &u32, b: &u32) -> u32 {
    return *a + *b;
}

fn max(a: u32, b: u32) -> u32 {
    if a > b {
        return a;
    } else {
        return b;
    }
}

fn sum_range(start: u32, end: u32) -> u32 {
    let n: u32 = start;
    let sum: u32 = 0;
    
    while n < end + 1 {
        sum = sum + n;
        n = n + 1;
    }

    return sum;
}

fn first(arr: [u32; 4]) -> u32 {
    return arr[0];
}

fn first_by_ref(arr: &[u32; 4]) -> u32 {
    return (*arr)[0];
}

extern "C" fn exit(status: u32) -> void;

fn main(argc: u32) -> u32 {
    let a: u32;
    a = 100;
    let c1: bool = 1000 > a;
    let c2: bool = 10 > argc;
    let p: &u32 = &argc;
    *p = max(1, 10);

    let foo: B;
    foo.inner.a = 1;
    foo.inner.c = 10;

    let sp: &B = &foo;
    (*sp).inner.a = 1;

    *p = foo.inner.get_a() + foo.inner.c;
    *p = foo.inner.get_a_by_ref() + foo.inner.c;

    let arr: [[u32; 4]; 2] = [
        [1, 2, a + 1, 4],
        [2, 4, a + 1, 4]
    ];

    if c1 {
        if c2 {
            a = sum_range(0, 10);
        } else {
            a = 2;
        }
    }

    let arr_ref: &[u32; 4] = &arr[0];
    let ptr: *u32 = arr_ref;
    let p2: *u32 = &arr[0][0] as *u32 + 2;
    let ref: &u32 = (p2 - 2) as &u32;

    // return add_by_ref(&argc, &a);
    return first_by_ref(&arr[0]) + arr[0][3] + A::get_static() + *(p2 - 1) + *ref;
}

// fn add_different_types(a: u32, b: u8) -> u16 {
//     return a + b;
// }