// TODO camel case vs. snake case

// --------------------------------------------------------------------------------------------------------------------
// BEGIN BINDINGS
// --------------------------------------------------------------------------------------------------------------------

const SDL_SCANCODE_A:         u32 = 4;
const SDL_SCANCODE_B:         u32 = 5;
const SDL_SCANCODE_C:         u32 = 6;
const SDL_SCANCODE_D:         u32 = 7;
const SDL_SCANCODE_E:         u32 = 8;
const SDL_SCANCODE_F:         u32 = 9;
const SDL_SCANCODE_G:         u32 = 10;
const SDL_SCANCODE_H:         u32 = 11;
const SDL_SCANCODE_I:         u32 = 12;
const SDL_SCANCODE_J:         u32 = 13;
const SDL_SCANCODE_K:         u32 = 14;
const SDL_SCANCODE_L:         u32 = 15;
const SDL_SCANCODE_M:         u32 = 16;
const SDL_SCANCODE_N:         u32 = 17;
const SDL_SCANCODE_O:         u32 = 18;
const SDL_SCANCODE_P:         u32 = 19;
const SDL_SCANCODE_Q:         u32 = 20;
const SDL_SCANCODE_R:         u32 = 21;
const SDL_SCANCODE_S:         u32 = 22;
const SDL_SCANCODE_T:         u32 = 23;
const SDL_SCANCODE_U:         u32 = 24;
const SDL_SCANCODE_V:         u32 = 25;
const SDL_SCANCODE_W:         u32 = 26;
const SDL_SCANCODE_X:         u32 = 27;
const SDL_SCANCODE_Y:         u32 = 28;
const SDL_SCANCODE_Z:         u32 = 29;
const SDL_SCANCODE_1:         u32 = 30;
const SDL_SCANCODE_2:         u32 = 31;
const SDL_SCANCODE_3:         u32 = 32;
const SDL_SCANCODE_4:         u32 = 33;
const SDL_SCANCODE_5:         u32 = 34;
const SDL_SCANCODE_6:         u32 = 35;
const SDL_SCANCODE_7:         u32 = 36;
const SDL_SCANCODE_8:         u32 = 37;
const SDL_SCANCODE_9:         u32 = 38;
const SDL_SCANCODE_0:         u32 = 39;
const SDL_SCANCODE_RETURN:    u32 = 40;
const SDL_SCANCODE_ESCAPE:    u32 = 41;
const SDL_SCANCODE_BACKSPACE: u32 = 42;
const SDL_SCANCODE_TAB:       u32 = 43;
const SDL_SCANCODE_SPACE:     u32 = 44;

const SDL_QUIT:               u32 = 256;
const SDL_KEYDOWN:            u32 = 768;
const SDL_KEYUP:              u32 = 769;

struct SDL_Keysym {
    scancode: u32;
    sym: u32;
    mod: u16;
    unused: u32;
}

struct SDL_KeyboardEvent {
    type: u32;
    timestamp: u32;
    windowID: u32;
    state: u8;
    repeat: u8;
    padding2: u8;
    padding3: u8;
    keysym: SDL_Keysym;
}

struct SDL_Event {
    type: u32;
    // TODO the rest, once we have unions
    _padding: [u8; 56];
}

struct SDL_Rect {
    x: u32;
    y: u32;
    w: u32;
    h: u32;
}

struct SDL_Window {}
struct SDL_Renderer {}
struct SDL_Surface {}
struct SDL_Texture {}

// TODO some of these need usize
extern "C" fn malloc(size: u32) -> *u8;
extern "C" fn realloc(ptr: *u8, new_size: u32) -> *u8;
extern "C" fn memcpy(dest: *u8, src: *u8, n: u32) -> *u8;
extern "C" fn free(ptr: *u8);
extern "C" fn exit(status: u32);
extern "C" fn sleep(seconds: u32) -> u32;
extern "C" fn putchar (c: u32) -> i32;
extern "C" fn puts(s: *i8) -> i32;
extern "C" fn random() -> u32;
extern "C" fn SDL_Init(flags: u32) -> i32;
extern "C" fn SDL_CreateWindow(title: *u8, x: u32, y: u32, w: u32, h: u32, flags: u32) -> *SDL_Window;
extern "C" fn SDL_PollEvent(ev: *u32) -> u32;
extern "C" fn SDL_GetWindowSurface(window: *u8) -> *SDL_Surface;
extern "C" fn SDL_UpdateWindowSurface(window: *u8) -> u32;
extern "C" fn SDL_GetError() -> *u8;
extern "C" fn SDL_ClearError();
extern "C" fn SDL_CreateRenderer(window: *SDL_Window, index: i32, flags: u32) -> *SDL_Renderer;
extern "C" fn SDL_RenderCopy(renderer: *SDL_Renderer, texture: *SDL_Texture, srcrect: *SDL_Rect, dstrect: *SDL_Rect) -> u32;
extern "C" fn SDL_CreateTextureFromSurface(renderer: *SDL_Renderer, surface: *SDL_Surface) -> *SDL_Texture;
extern "C" fn SDL_FreeSurface(surface: *SDL_Surface);
extern "C" fn SDL_RenderPresent(renderer: *SDL_Renderer);
extern "C" fn SDL_Delay(ms: u32);
extern "C" fn SDL_RenderClear(renderer: *SDL_Renderer) -> u32;
extern "C" fn IMG_Init(flags: i32) -> i32;
extern "C" fn IMG_Load(file: *u8) -> *SDL_Surface;

// --------------------------------------------------------------------------------------------------------------------
// END BINDINGS
// --------------------------------------------------------------------------------------------------------------------

fn abort(msg: &u8) {
    puts(msg);
    exit(1);
}

fn rand_range(lower: u32, upper: u32) -> u32 {
    return random() % (upper + 1 - lower) + lower;
}

fn itoa(n: u32, buf: *u8) {
    let divisor: u32 = 1000000000;
    
    while n / divisor == 0 {
        divisor = divisor / 10;
    }

    divisor = divisor * 10;

    while divisor != 1 {
        *buf = ((n % divisor) / divisor / 10 + 48);
        divisor = divisor / 10;
        buf = buf + 1;
    }
    
    // buf = buf + 1;
    *buf = 0;
}

struct Pos {
    x: i32;
    y: i32;
}

struct Sprite {
    tileX: u32;
    tileY: u32;
    tileW: u32;
    tileH: u32;
}

struct SpriteSheet {
    tileSize: u32;
    tex: *SDL_Texture;
}

impl SpriteSheet {
    fn new(tileSize: u32, tex: *SDL_Texture) -> Self {
        let spritesheet: SpriteSheet;
        spritesheet.tileSize = tileSize;
        spritesheet.tex = tex;
        return spritesheet;
    }

    fn drawTile(&self, renderer: *SDL_Renderer, sprite: &Sprite, dstRect: &SDL_Rect) {
        let srcRect: SDL_Rect = makeRect(
            sprite.tileX * self.tileSize,
            sprite.tileY * self.tileSize,
            sprite.tileW * self.tileSize,
            sprite.tileH * self.tileSize
        );

        if SDL_RenderCopy(renderer, self.tex, &srcRect, dstRect) < 0 {
            puts(SDL_GetError());
        }
    }
}

struct InputState {
    up: bool;
    down: bool;
    left: bool;
    right: bool;
    shoot: bool;
}

impl InputState {
    fn new() -> Self {
        let input: Self;
        input.up = false;
        input.down = false;
        input.left = false;
        input.right = false;
        input.shoot = false;
        return input;
    }
}

struct Player {
    pos: Pos;
    sprite: Sprite;
    w: u32;
    h: u32;
    speed: u32;
    animState: u32;
    animTicksLeft: u32;
    shootCooldown: u32;
    shootTicksLeft: u32;
}

struct Bullet {
    is_alive: bool;
    pos: Pos;
}

struct Enemy {
    is_alive: bool;
    pos: Pos;
}

struct EntityList<T> {
    len: u32;
    cap: u32;
    ptr: *T;
}

impl EntityList<T> {
    fn init(&self, cap: u32) {
        self.len = 0;
        self.cap = cap;
        self.ptr = malloc(sizeof(T) * cap);
    }

    fn get(&self, id: u32) -> &T {
        if self.ptr != nullptr && id < self.len {
            return self.ptr + id;
        }
        return nullptr;
    }

    fn kill(&self, id: u32) {
        self.get(id).is_alive = 0;
    }

    fn spawn(&self, entity: *T) -> u32 {
        let idx: u32 = 0;
        if self.len < self.cap {
            idx = self.len;
            self.len = self.len + 1;
        } else {
            let run: bool = true; // TODO we have no 'break' yet lmao
            while idx < self.len && run {
                let b: &T = self.get(idx);
                if !b.is_alive {
                    run = false;
                } else {
                    idx = idx + 1;
                }
            }
        }
        
        if self.ptr != nullptr && idx < self.len {
            memcpy(self.ptr + idx, entity, sizeof(T));
        }

        return idx;
    }

    fn despawn(&self, id: u32) {
        self.get(id).is_alive = false;
    }
}

struct GameContext {
    window_w: u32;
    window_h: u32;
    renderer: *SDL_Renderer;
    spritesheet: SpriteSheet;
    score: u32;
    enemies: EntityList<Enemy>;
    bullets: EntityList<Bullet>;
    enemy_spawn_cooldown: u32;
    enemy_spawn_ticks_left: u32;
}

const BULLET_SPEED: u32 = 6;

// TODO do not treat this as a generic impl
// impl Foo<u32> {}
// generics for the impl should be the ones following the keyword 'impl', the struct ones should be type args

// TODO remove when we have struct literals
fn makeRect(x: u32, y: u32, w: u32, h: u32) -> SDL_Rect {
    let rect: SDL_Rect;
    rect.x = x;
    rect.y = y;
    rect.w = w;
    rect.h = h;
    return rect;
}

// TODO remove when we have struct literals
fn makeSprite(tileX: u32, tileY: u32, tileW: u32, tileH: u32) -> Sprite {
    let sprite: Sprite;
    sprite.tileX = tileX;
    sprite.tileY = tileY;
    sprite.tileW = tileW;
    sprite.tileH = tileH;
    return sprite;
}

// TODO remove when we have struct literals
fn makePlayer(windowW: u32, windowH: u32) -> Player {
    let player: Player;
    player.sprite = makeSprite(0, 0, 1, 1);
    player.w = 32;
    player.h = 32;
    player.speed = 3;
    player.animState = 0;
    player.animTicksLeft = 30;
    player.pos.x = 200;
    player.pos.y = windowH - player.h;
    player.shootCooldown = 30;
    player.shootTicksLeft = 0;
    return player;
}

// TODO remove when we have struct literals
fn makeBullet(x: u32, y: u32) -> Bullet {
    let bullet: Bullet;
    bullet.is_alive = true;
    bullet.pos.x = x;
    bullet.pos.y = y;
    return bullet;
}

// TODO remove when we have struct literals
fn makeEnemy(x: u32, y: u32) -> Enemy {
    let enemy: Enemy;
    enemy.is_alive = true;
    enemy.pos.x = x;
    enemy.pos.y = y;
    return enemy;
}

fn main(argc: u32) -> u32 {
    let buf: [u8; 16];
    let pBuf: *u8 = &buf;
    itoa(12345678, pBuf);
    puts(pBuf);
    itoa(80084, pBuf);
    puts(pBuf);

    let ctx: GameContext;
    ctx.window_w = 400;
    ctx.window_h = 600;
    
    ctx.score = 0;

    if SDL_Init(32) < 0 {
        abort(SDL_GetError());
    }

    if IMG_Init(2) < 0 {
        abort(SDL_GetError());
    }

    let window: *SDL_Window = SDL_CreateWindow("schut", 800, 400, ctx.window_w, ctx.window_h, 4);
    if window == nullptr {
        abort(SDL_GetError());
    }

    ctx.renderer = SDL_CreateRenderer(window, -1, 1);
    if ctx.renderer == nullptr {
        abort(SDL_GetError());
    }

    let surface: *SDL_Surface = SDL_GetWindowSurface(window);
    if surface == nullptr {
        abort(SDL_GetError());
    }

    let img: *SDL_Surface = IMG_Load("spritesheet.png");
    if img == nullptr {
        abort(SDL_GetError());
    }

    let texSpritesheet: *SDL_Texture = SDL_CreateTextureFromSurface(ctx.renderer, img);
    SDL_FreeSurface(img);
    if texSpritesheet == nullptr {
        abort(SDL_GetError());
    }
    
    ctx.spritesheet = SpriteSheet::new(16, texSpritesheet);
    
    let ev: SDL_Event;
    let kb_event: SDL_KeyboardEvent;

    let input: InputState = InputState::new();

    let player: Player = makePlayer(ctx.window_w, ctx.window_h);

    ctx.bullets.init(100);
    ctx.enemies.init(100);

    ctx.enemy_spawn_cooldown = 60;
    ctx.enemy_spawn_ticks_left = 0;

    while true {
        while SDL_PollEvent(&ev) == 1 {
            if ev.type == SDL_QUIT {
                exit(0);
            }

            if ev.type == SDL_KEYDOWN {
                kb_event = ev;
                if kb_event.keysym.scancode == SDL_SCANCODE_ESCAPE {
                    exit(0);
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_W {
                    input.up = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_A {
                    input.left = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_S {
                    input.down = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_D {
                    input.right = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_SPACE {
                    input.shoot = true;
                }
            }

            if ev.type == SDL_KEYUP {
                kb_event = ev;
                if kb_event.keysym.scancode == SDL_SCANCODE_W {
                    input.up = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_A {
                    input.left = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_S {
                    input.down = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_D {
                    input.right = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_SPACE {
                    input.shoot = false;
                }
            }
        }
        
        if input.up && player.pos.y > 0 {
            player.pos.y = player.pos.y - player.speed;
        }
        if input.left && player.pos.x > 0 {
            player.pos.x = player.pos.x - player.speed;
        }
        if input.down && player.pos.y < (ctx.window_h - player.h) {
            player.pos.y = player.pos.y + player.speed;
        }
        if input.right && player.pos.x < (ctx.window_w - player.w) {
            player.pos.x = player.pos.x + player.speed;
        }
        
        if player.shootTicksLeft > 0 {
            player.shootTicksLeft = player.shootTicksLeft - 1;
        } else {
            if input.shoot {
                let bullet: Bullet = makeBullet(player.pos.x, player.pos.y - 20);
                ctx.bullets.spawn(&bullet);
                player.shootTicksLeft = player.shootCooldown;
            } 
        }

        if ctx.enemy_spawn_ticks_left == 0 {
            let margin_x: u32 = 10;
            let x: u32 = rand_range(margin_x, ctx.window_w - 32 - margin_x);
            let enemy: Enemy = makeEnemy(x, 32);
            ctx.enemies.spawn(&enemy);
            ctx.enemy_spawn_ticks_left = ctx.enemy_spawn_cooldown;
        } else {
            ctx.enemy_spawn_ticks_left = ctx.enemy_spawn_ticks_left - 1;
        }

        SDL_RenderClear(ctx.renderer);

        if player.animTicksLeft == 0 {
            if player.animState == 0 {
                player.animState = 1;
                player.sprite.tileX = 1;
            } else {
                player.animState = 0;
                player.sprite.tileX = 0;
            }
            player.animTicksLeft = 30; 
        } else {
            player.animTicksLeft = player.animTicksLeft - 1;
        }

        let dstRect: SDL_Rect = makeRect(player.pos.x, player.pos.y, player.w, player.h);
        ctx.spritesheet.drawTile(ctx.renderer, &player.sprite, &dstRect);

        // FIXME
        // spritesheet.drawTile(renderer, &player.sprite, &makeRect(player.pos.x, player.pos.y, player.w, player.h));

        update_enemies(&ctx);
        update_bullets(&ctx);

        SDL_RenderPresent(ctx.renderer);
        SDL_Delay(16);
    }

    return 0;
}

fn aabb(a: &SDL_Rect, b: &SDL_Rect) -> bool {
    return
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y;
}

// TODO these should take a &Ctx
fn update_enemies(ctx: &GameContext) {
    let sprite: Sprite = makeSprite(3, 0, 1, 1);

    let i: u32 = 0;
    while i < ctx.enemies.len {
        let enemy: &Enemy = ctx.enemies.get(i);
        if enemy.is_alive {
            // Check bullet collisions
            let bullet_idx: u32 = 0;
            while bullet_idx < ctx.bullets.len {
                let bullet: &Bullet = ctx.bullets.get(bullet_idx);
                if bullet.is_alive {
                    let enemy_rect:  SDL_Rect = makeRect(enemy.pos.x, enemy.pos.y, 32, 32);
                    let bullet_rect: SDL_Rect = makeRect(bullet.pos.x, bullet.pos.y, 16, 16);
    
                    if aabb(&enemy_rect, &bullet_rect) {
                        enemy.is_alive = false;
                        bullet.is_alive = false;

                        ctx.score = ctx.score + 10;
                    }
                }

                bullet_idx = bullet_idx + 1;
            }

            enemy.pos.y = enemy.pos.y + 2;
            if enemy.pos.y > ctx.window_h {
                enemy.is_alive = false;
            }

            // Draw
            let dstRect: SDL_Rect = makeRect(enemy.pos.x, enemy.pos.y, 32, 32);
            ctx.spritesheet.drawTile(ctx.renderer, &sprite, &dstRect);
        }
        i = i + 1;
    }
}

fn update_bullets(ctx: &GameContext) {
    let sprite: Sprite = makeSprite(2, 0, 1, 1);

    let i: u32 = 0;
    while i < ctx.bullets.len {
        let bullet: &Bullet = ctx.bullets.get(i);
        if bullet.is_alive {
            let dstRect: SDL_Rect = makeRect(bullet.pos.x, bullet.pos.y, 32, 32);
            ctx.spritesheet.drawTile(ctx.renderer, &sprite, &dstRect);

            bullet.pos.y = bullet.pos.y - BULLET_SPEED;
            if bullet.pos.y < 0 {
                ctx.bullets.despawn(i);
            }
        }
        i = i + 1;
    }
}