struct SDL_Keysym {
    scancode: u32;
    sym: u32;
    mod: u16;
    unused: u32;
}

struct SDL_KeyboardEvent {
    type: u32;
    timestamp: u32;
    windowID: u32;
    state: u8;
    repeat: u8;
    padding2: u8;
    padding3: u8;
    keysym: SDL_Keysym;
}

struct SDL_Event {
    type: u32;
    // TODO the rest, once we have unions
    _padding: [u8; 56];
}

struct SDL_Rect {
    x: u32;
    y: u32;
    w: u32;
    h: u32;
}

struct SDL_Window {}
struct SDL_Renderer {}
struct SDL_Surface {}
struct SDL_Texture {}

// TODO some of these need usize
extern "C" fn malloc(size: u64) -> *void;
extern "C" fn realloc(ptr: *void, new_size: u64) -> *void;
extern "C" fn memcpy(dest: *void, src: *void, n: u64) -> *void;
extern "C" fn free(ptr: *void) -> void;
extern "C" fn exit(status: u32) -> void;
extern "C" fn sleep(seconds: u32) -> u32;
extern "C" fn puts(s: *i8) -> i32;
extern "C" fn SDL_Init(flags: u32) -> i32;
extern "C" fn SDL_CreateWindow(title: *u8, x: u32, y: u32, w: u32, h: u32, flags: u32) -> *SDL_Window;
extern "C" fn SDL_PollEvent(ev: *u32) -> u32;
extern "C" fn SDL_GetWindowSurface(window: *u8) -> *SDL_Surface;
extern "C" fn SDL_UpdateWindowSurface(window: *u8) -> u32;
extern "C" fn SDL_GetError() -> *u8;
extern "C" fn SDL_ClearError() -> void;
extern "C" fn SDL_CreateRenderer(window: *SDL_Window, index: i32, flags: u32) -> *SDL_Renderer;
extern "C" fn SDL_RenderCopy(renderer: *SDL_Renderer, texture: *SDL_Texture, srcrect: *SDL_Rect, dstrect: *SDL_Rect) -> u32;
extern "C" fn SDL_CreateTextureFromSurface(renderer: *SDL_Renderer, surface: *SDL_Surface) -> *SDL_Texture;
extern "C" fn SDL_FreeSurface(surface: *SDL_Surface) -> void;
extern "C" fn SDL_RenderPresent(renderer: *SDL_Renderer) -> void;
extern "C" fn SDL_Delay(ms: u32) -> void;
extern "C" fn SDL_RenderClear(renderer: *SDL_Renderer) -> u32;
extern "C" fn IMG_Init(flags: i32) -> i32;
extern "C" fn IMG_Load(file: *u8) -> *SDL_Surface;

struct Pos {
    x: i32;
    y: i32;
}

struct Sprite {
    tileX: u32;
    tileY: u32;
    tileW: u32;
    tileH: u32;
}

struct SpriteSheet {
    tileSize: u32;
    tex: *SDL_Texture;
}

impl SpriteSheet {
    // TODO borked
    fn new(tileSize: u32, tex: *SDL_Texture) -> SpriteSheet {
        let spritesheet: SpriteSheet;
        spritesheet.tileSize = tileSize;
        spritesheet.tex = tex;
        return spritesheet;
    }
}

struct Player {
    pos: Pos;
    sprite: Sprite;
    w: u32;
    h: u32;
    speed: u32;
    animState: u32;
    animTicksLeft: u32;
}

fn main(argc: u32) -> u32 {
    let windowW: u32 = 400;
    let windowH: u32 = 600;

    let title: [u8; 5] = "game";
    let pTitle: *u8 = &title;

    let texPath: [u8; 16] = "spritesheet.png";
    let pTexPath: *u8 = &texPath;

    if SDL_Init(32) < 0 {
        puts(SDL_GetError());
        return 1;
    }

    if IMG_Init(2) < 0 {
        puts(SDL_GetError());
        return 1;
    }

    let window: *SDL_Window = SDL_CreateWindow(pTitle, 0, 0, windowW, windowH, 4);
    if window == nullptr {
        puts(SDL_GetError());
    }

    let renderer: *SDL_Renderer = SDL_CreateRenderer(window, -1, 1);
    if renderer == nullptr {
        puts(SDL_GetError());
    }

    let surface: *SDL_Surface = SDL_GetWindowSurface(window);
    if surface == nullptr {
        puts(SDL_GetError());
    }

    let img: *SDL_Surface = IMG_Load(pTexPath);
    if img == nullptr {
        puts(SDL_GetError());
    }

    let tex: *SDL_Texture = SDL_CreateTextureFromSurface(renderer, img);
    if tex == nullptr {
        puts(SDL_GetError());
    }

    SDL_FreeSurface(img);

    let srcRect: SDL_Rect;
    srcRect.x = 0;
    srcRect.y = 0;
    srcRect.w = 16;
    srcRect.h = 32;

    let dstRect: SDL_Rect;
    dstRect.x = 200;
    dstRect.y = 100;
    dstRect.w = 80;
    dstRect.h = 80;

    
    let ev: SDL_Event;
    let kb_event: SDL_KeyboardEvent;

    let input_up:    bool = false;
    let input_down:  bool = false;
    let input_left:  bool = false;
    let input_right: bool = false;

    // TODO really need struct literals
    let player: Player;
    player.pos.x = 200;
    player.pos.y = 200;
    player.sprite.tileW = 1;
    player.sprite.tileH = 2;
    player.sprite.tileX = 0;
    player.sprite.tileY = 0;
    player.w = 32;
    player.h = 64;
    player.speed = 3;
    player.animState = 0;
    player.animTicksLeft = 30;

    while true {
        while SDL_PollEvent(&ev) == 1 {
            if ev.type == 256 { // quit event
                exit(0);
            }

            if ev.type == 768 { // keydown event
                kb_event = ev;
                if kb_event.keysym.scancode == 41 { // ESC
                    exit(0);
                }
                if kb_event.keysym.scancode == 26 { // w
                    input_up = true;
                }
                if kb_event.keysym.scancode == 4 { // a
                    input_left = true;
                }
                if kb_event.keysym.scancode == 22 { // s
                    input_down = true;
                }
                if kb_event.keysym.scancode == 7 { // d
                    input_right = true;
                }
            }

            if ev.type == 769 { // keydown event
                kb_event = ev;
                if kb_event.keysym.scancode == 26 { // w
                    input_up = false;
                }
                if kb_event.keysym.scancode == 4 { // a
                    input_left = false;
                }
                if kb_event.keysym.scancode == 22 { // s
                    input_down = false;
                }
                if kb_event.keysym.scancode == 7 { // d
                    input_right = false;
                }
            }
        }
        
        if input_up {
            if player.pos.y > 0 {
                player.pos.y = player.pos.y - player.speed;
            }
        }
        if input_left {
            if player.pos.x > 0 {
                player.pos.x = player.pos.x - player.speed;
            }
        }
        if input_down {
            if player.pos.y < (windowH - player.h) {
                player.pos.y = player.pos.y + player.speed;
            }
        }
        if input_right {
            if player.pos.x < (windowW - player.w) {
                player.pos.x = player.pos.x + player.speed;
            }
        }

        SDL_RenderClear(renderer);

        if player.animTicksLeft == 0 {
            if player.animState == 0 {
                player.animState = 1;
                player.sprite.tileX = 1;
            } else {
                player.animState = 0;
                player.sprite.tileX = 0;
            }
            player.animTicksLeft = 30; 
        } else {
            player.animTicksLeft = player.animTicksLeft - 1;
        }

        srcRect.x = player.sprite.tileX * 16;
        srcRect.y = 0;
        srcRect.w = player.sprite.tileW * 16;
        srcRect.h = player.sprite.tileH * 16;

        dstRect.x = player.pos.x;
        dstRect.y = player.pos.y;
        dstRect.w = player.w;
        dstRect.h = player.h;

        if SDL_RenderCopy(renderer, tex, &srcRect, &dstRect) < 0 {
            puts(SDL_GetError());
        }

        SDL_RenderPresent(renderer);
        SDL_Delay(16);
    }

    return 0;
}