// --------------------------------------------------------------------------------------------------------------------
// BEGIN BINDINGS
// --------------------------------------------------------------------------------------------------------------------

struct SDL_Keysym {
    scancode: u32;
    sym: u32;
    mod: u16;
    unused: u32;
}

struct SDL_KeyboardEvent {
    type: u32;
    timestamp: u32;
    windowID: u32;
    state: u8;
    repeat: u8;
    padding2: u8;
    padding3: u8;
    keysym: SDL_Keysym;
}

const SDL_SCANCODE_A:         u32 = 4;
const SDL_SCANCODE_B:         u32 = 5;
const SDL_SCANCODE_C:         u32 = 6;
const SDL_SCANCODE_D:         u32 = 7;
const SDL_SCANCODE_E:         u32 = 8;
const SDL_SCANCODE_F:         u32 = 9;
const SDL_SCANCODE_G:         u32 = 10;
const SDL_SCANCODE_H:         u32 = 11;
const SDL_SCANCODE_I:         u32 = 12;
const SDL_SCANCODE_J:         u32 = 13;
const SDL_SCANCODE_K:         u32 = 14;
const SDL_SCANCODE_L:         u32 = 15;
const SDL_SCANCODE_M:         u32 = 16;
const SDL_SCANCODE_N:         u32 = 17;
const SDL_SCANCODE_O:         u32 = 18;
const SDL_SCANCODE_P:         u32 = 19;
const SDL_SCANCODE_Q:         u32 = 20;
const SDL_SCANCODE_R:         u32 = 21;
const SDL_SCANCODE_S:         u32 = 22;
const SDL_SCANCODE_T:         u32 = 23;
const SDL_SCANCODE_U:         u32 = 24;
const SDL_SCANCODE_V:         u32 = 25;
const SDL_SCANCODE_W:         u32 = 26;
const SDL_SCANCODE_X:         u32 = 27;
const SDL_SCANCODE_Y:         u32 = 28;
const SDL_SCANCODE_Z:         u32 = 29;
const SDL_SCANCODE_1:         u32 = 30;
const SDL_SCANCODE_2:         u32 = 31;
const SDL_SCANCODE_3:         u32 = 32;
const SDL_SCANCODE_4:         u32 = 33;
const SDL_SCANCODE_5:         u32 = 34;
const SDL_SCANCODE_6:         u32 = 35;
const SDL_SCANCODE_7:         u32 = 36;
const SDL_SCANCODE_8:         u32 = 37;
const SDL_SCANCODE_9:         u32 = 38;
const SDL_SCANCODE_0:         u32 = 39;
const SDL_SCANCODE_RETURN:    u32 = 40;
const SDL_SCANCODE_ESCAPE:    u32 = 41;
const SDL_SCANCODE_BACKSPACE: u32 = 42;
const SDL_SCANCODE_TAB:       u32 = 43;
const SDL_SCANCODE_SPACE:     u32 = 44;

struct SDL_Event {
    type: u32;
    // TODO the rest, once we have unions
    _padding: [u8; 56];
}

struct SDL_Rect {
    x: u32;
    y: u32;
    w: u32;
    h: u32;
}

struct SDL_Window {}
struct SDL_Renderer {}
struct SDL_Surface {}
struct SDL_Texture {}

// TODO some of these need usize
extern "C" fn malloc(size: u32) -> *u8;
extern "C" fn realloc(ptr: *u8, new_size: u32) -> *u8;
extern "C" fn memcpy(dest: *u8, src: *u8, n: u32) -> *u8;
extern "C" fn free(ptr: *u8);
extern "C" fn exit(status: u32);
extern "C" fn sleep(seconds: u32) -> u32;
extern "C" fn puts(s: *i8) -> i32;
extern "C" fn SDL_Init(flags: u32) -> i32;
extern "C" fn SDL_CreateWindow(title: *u8, x: u32, y: u32, w: u32, h: u32, flags: u32) -> *SDL_Window;
extern "C" fn SDL_PollEvent(ev: *u32) -> u32;
extern "C" fn SDL_GetWindowSurface(window: *u8) -> *SDL_Surface;
extern "C" fn SDL_UpdateWindowSurface(window: *u8) -> u32;
extern "C" fn SDL_GetError() -> *u8;
extern "C" fn SDL_ClearError();
extern "C" fn SDL_CreateRenderer(window: *SDL_Window, index: i32, flags: u32) -> *SDL_Renderer;
extern "C" fn SDL_RenderCopy(renderer: *SDL_Renderer, texture: *SDL_Texture, srcrect: *SDL_Rect, dstrect: *SDL_Rect) -> u32;
extern "C" fn SDL_CreateTextureFromSurface(renderer: *SDL_Renderer, surface: *SDL_Surface) -> *SDL_Texture;
extern "C" fn SDL_FreeSurface(surface: *SDL_Surface);
extern "C" fn SDL_RenderPresent(renderer: *SDL_Renderer);
extern "C" fn SDL_Delay(ms: u32);
extern "C" fn SDL_RenderClear(renderer: *SDL_Renderer) -> u32;
extern "C" fn IMG_Init(flags: i32) -> i32;
extern "C" fn IMG_Load(file: *u8) -> *SDL_Surface;

// --------------------------------------------------------------------------------------------------------------------
// END BINDINGS
// --------------------------------------------------------------------------------------------------------------------

struct Pos {
    x: i32;
    y: i32;
}

struct Sprite {
    tileX: u32;
    tileY: u32;
    tileW: u32;
    tileH: u32;
}

struct SpriteSheet {
    tileSize: u32;
    tex: *SDL_Texture;
}

impl SpriteSheet {
    fn new(tileSize: u32, tex: *SDL_Texture) -> SpriteSheet {
        let spritesheet: SpriteSheet;
        spritesheet.tileSize = tileSize;
        spritesheet.tex = tex;
        return spritesheet;
    }

    fn drawTile(self: &Self, renderer: *SDL_Renderer, sprite: &Sprite, dstRect: &SDL_Rect) {
        let srcRect: SDL_Rect;
        srcRect.x = sprite.tileX * self.tileSize;
        srcRect.y = sprite.tileY * self.tileSize;
        srcRect.w = sprite.tileW * self.tileSize;
        srcRect.h = sprite.tileH * self.tileSize;

        if SDL_RenderCopy(renderer, self.tex, &srcRect, dstRect) < 0 {
            puts(SDL_GetError());
        }
    }
}

struct InputState {
    up: bool;
    down: bool;
    left: bool;
    right: bool;
    shoot: bool;
}

impl InputState {
    fn new() -> Self {
        let input: Self;
        input.up = false;
        input.down = false;
        input.left = false;
        input.right = false;
        input.shoot = false;
        return input;
    }
}

struct Player {
    pos: Pos;
    sprite: Sprite;
    w: u32;
    h: u32;
    speed: u32;
    animState: u32;
    animTicksLeft: u32;
}

struct Bullet {
    isAlive: bool;
    pos: Pos;
}

struct BulletList {
    len: u32;
    cap: u32;
    //ptr: *Sprite; TODO this fails
    ptr: *u8;
}

impl BulletList {
    fn new(cap: u32) -> Self {
        let list: BulletList;
        list.len = 0;
        list.cap = cap;
        // TODO #[sizeof T]
        list.ptr = malloc(16 * cap);
        return list;
    }

    fn spawn(self: &Self, bullet: *Bullet) -> u32 {
        let idx: u32 = 0;
        if self.len < self.cap {
            idx = self.len;
            self.len = self.len + 1;
        } else {
            let run: bool = true; // TODO we have no 'break' yet lmao
            while idx < self.len && run {
                let b: &Bullet = self.get(idx);
                if !b.isAlive {
                    run = false;
                } else {
                    idx = idx + 1;
                }
            }
        }
        
        if self.ptr != nullptr && idx < self.len {
            memcpy(self.ptr + (idx * 16), bullet, 16);
        }

        return idx;
    }

    fn despawn(self: &Self, id: u32) {
        self.get(id).isAlive = false;
    }

    fn get(self: &Self, id: u32) -> &Bullet {
        // TODO because this returns, do not emit a br
        if self.ptr != nullptr && id < self.len {
            return self.ptr + (id * 16);
        }
        return nullptr;
    }

    fn kill(self: &Self, id: u32) {
        self.get(id).isAlive = 0;
    }
}

const BULLET_SPEED: u32 = 4;

fn main(argc: u32) -> u32 {
    let windowW: u32 = 400;
    let windowH: u32 = 600;

    let title: [u8; 5] = "game";
    let pTitle: *u8 = &title;

    let texPath: [u8; 16] = "spritesheet.png";
    let pTexPath: *u8 = &texPath;

    SDL_Init(32);

    IMG_Init(2);

    let window: *SDL_Window = SDL_CreateWindow(pTitle, 0, 0, windowW, windowH, 4);
    if window == nullptr {
        puts(SDL_GetError());
    }

    let renderer: *SDL_Renderer = SDL_CreateRenderer(window, -1, 1);
    if renderer == nullptr {
        puts(SDL_GetError());
    }

    let surface: *SDL_Surface = SDL_GetWindowSurface(window);
    if surface == nullptr {
        puts(SDL_GetError());
    }

    let img: *SDL_Surface = IMG_Load(pTexPath);
    if img == nullptr {
        puts(SDL_GetError());
    }

    let texSpritesheet: *SDL_Texture = SDL_CreateTextureFromSurface(renderer, img);
    if texSpritesheet == nullptr {
        puts(SDL_GetError());
    }
    SDL_FreeSurface(img);
    
    let spritesheet: SpriteSheet = SpriteSheet::new(16, texSpritesheet);


    let srcRect: SDL_Rect;
    srcRect.x = 0;
    srcRect.y = 0;
    srcRect.w = 16;
    srcRect.h = 32;

    let dstRect: SDL_Rect;
    dstRect.x = 200;
    dstRect.y = 100;
    dstRect.w = 80;
    dstRect.h = 80;
    
    let ev: SDL_Event;
    let kb_event: SDL_KeyboardEvent;

    let input: InputState = InputState::new();

    // TODO really need struct literals
    let player: Player;
    player.sprite.tileW = 1;
    player.sprite.tileH = 2;
    player.sprite.tileX = 0;
    player.sprite.tileY = 0;
    player.w = 32;
    player.h = 64;
    player.speed = 3;
    player.animState = 0;
    player.animTicksLeft = 30;
    player.pos.x = 200;
    player.pos.y = windowH - player.h;

    let shootCooldown: u32 = 0;
    let bulletList: BulletList = BulletList::new(10);

    let bullet: Bullet;

    let bulletSprite: Sprite;
    bulletSprite.tileX = 10;
    bulletSprite.tileY = 0;
    bulletSprite.tileW = 1;
    bulletSprite.tileH = 1;

    while true {
        while SDL_PollEvent(&ev) == 1 {
            if ev.type == 256 { // quit event
                exit(0);
            }

            if ev.type == 768 { // keydown event
                kb_event = ev;
                if kb_event.keysym.scancode == SDL_SCANCODE_ESCAPE {
                    exit(0);
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_W {
                    input.up = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_A {
                    input.left = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_S {
                    input.down = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_D {
                    input.right = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_SPACE {
                    input.shoot = true;
                }
            }

            if ev.type == 769 { // keydown event
                kb_event = ev;
                if kb_event.keysym.scancode == SDL_SCANCODE_W {
                    input.up = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_A {
                    input.left = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_S {
                    input.down = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_D {
                    input.right = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_SPACE {
                    input.shoot = false;
                }
            }
        }
        
        if input.up && player.pos.y > 0 {
            player.pos.y = player.pos.y - player.speed;
        }
        if input.left && player.pos.x > 0 {
            player.pos.x = player.pos.x - player.speed;
        }
        if input.down && player.pos.y < (windowH - player.h) {
            player.pos.y = player.pos.y + player.speed;
        }
        if input.right && player.pos.x < (windowW - player.w) {
            player.pos.x = player.pos.x + player.speed;
        }
        
        if shootCooldown > 0 {
            shootCooldown = shootCooldown - 1;
        } else {
            if input.shoot {
                bullet.isAlive = true;
                bullet.pos.x = player.pos.x + 8;
                bullet.pos.y = player.pos.y - 20;
                bulletList.spawn(&bullet);
                shootCooldown = 30;
            } 
        }

        SDL_RenderClear(renderer);

        if player.animTicksLeft == 0 {
            if player.animState == 0 {
                player.animState = 1;
                player.sprite.tileX = 1;
            } else {
                player.animState = 0;
                player.sprite.tileX = 0;
            }
            player.animTicksLeft = 30; 
        } else {
            player.animTicksLeft = player.animTicksLeft - 1;
        }

        dstRect.x = player.pos.x;
        dstRect.y = player.pos.y;
        dstRect.w = player.w;
        dstRect.h = player.h;

        spritesheet.drawTile(renderer, &player.sprite, &dstRect);

        let i: u32 = 0;
        while i < bulletList.len {
            let bullet: &Bullet = bulletList.get(i);

            if bullet.isAlive {
                dstRect.x = bullet.pos.x;
                dstRect.y = bullet.pos.y;
                dstRect.w = 16;
                dstRect.h = 16;
                spritesheet.drawTile(renderer, &bulletSprite, &dstRect);

                bullet.pos.y = bullet.pos.y - BULLET_SPEED;
                if bullet.pos.y < 0 {
                    bulletList.despawn(i);
                }
            }
            i = i + 1;
        }

        SDL_RenderPresent(renderer);
        SDL_Delay(16);
    }

    return 0;
}