// TODO camel case vs. snake case

// --------------------------------------------------------------------------------------------------------------------
// BEGIN BINDINGS
// --------------------------------------------------------------------------------------------------------------------

const SDL_INIT_VIDEO:         u32 = 32;
const SDL_INIT_AUDIO:         u32 = 16;

const SDL_SCANCODE_A:         u32 = 4;
const SDL_SCANCODE_B:         u32 = 5;
const SDL_SCANCODE_C:         u32 = 6;
const SDL_SCANCODE_D:         u32 = 7;
const SDL_SCANCODE_E:         u32 = 8;
const SDL_SCANCODE_F:         u32 = 9;
const SDL_SCANCODE_G:         u32 = 10;
const SDL_SCANCODE_H:         u32 = 11;
const SDL_SCANCODE_I:         u32 = 12;
const SDL_SCANCODE_J:         u32 = 13;
const SDL_SCANCODE_K:         u32 = 14;
const SDL_SCANCODE_L:         u32 = 15;
const SDL_SCANCODE_M:         u32 = 16;
const SDL_SCANCODE_N:         u32 = 17;
const SDL_SCANCODE_O:         u32 = 18;
const SDL_SCANCODE_P:         u32 = 19;
const SDL_SCANCODE_Q:         u32 = 20;
const SDL_SCANCODE_R:         u32 = 21;
const SDL_SCANCODE_S:         u32 = 22;
const SDL_SCANCODE_T:         u32 = 23;
const SDL_SCANCODE_U:         u32 = 24;
const SDL_SCANCODE_V:         u32 = 25;
const SDL_SCANCODE_W:         u32 = 26;
const SDL_SCANCODE_X:         u32 = 27;
const SDL_SCANCODE_Y:         u32 = 28;
const SDL_SCANCODE_Z:         u32 = 29;
const SDL_SCANCODE_1:         u32 = 30;
const SDL_SCANCODE_2:         u32 = 31;
const SDL_SCANCODE_3:         u32 = 32;
const SDL_SCANCODE_4:         u32 = 33;
const SDL_SCANCODE_5:         u32 = 34;
const SDL_SCANCODE_6:         u32 = 35;
const SDL_SCANCODE_7:         u32 = 36;
const SDL_SCANCODE_8:         u32 = 37;
const SDL_SCANCODE_9:         u32 = 38;
const SDL_SCANCODE_0:         u32 = 39;
const SDL_SCANCODE_RETURN:    u32 = 40;
const SDL_SCANCODE_ESCAPE:    u32 = 41;
const SDL_SCANCODE_BACKSPACE: u32 = 42;
const SDL_SCANCODE_TAB:       u32 = 43;
const SDL_SCANCODE_SPACE:     u32 = 44;

const SDL_QUIT:               u32 = 256;
const SDL_KEYDOWN:            u32 = 768;
const SDL_KEYUP:              u32 = 769;

struct SDL_Keysym {
    scancode: u32;
    sym: u32;
    mod: u16;
    unused: u32;
}

struct SDL_KeyboardEvent {
    type: u32;
    timestamp: u32;
    windowID: u32;
    state: u8;
    repeat: u8;
    padding2: u8;
    padding3: u8;
    keysym: SDL_Keysym;
}

struct SDL_Event {
    type: u32;
    // TODO the rest, once we have unions
    _padding: [u8; 56];
}

struct SDL_Rect {
    x: u32;
    y: u32;
    w: u32;
    h: u32;
}
// TODO
// type Rect = SDL_Rect;

// TODO
struct SDL_Color {
    r: u8;
    g: u8;
    b: u8;
    a: u8;
}

struct SDL_Window {}
struct SDL_Renderer {}
struct SDL_Surface {}
struct SDL_Texture {}
struct TTF_Font {}
struct Mix_Music {}
struct Mix_Chunk {}

// TODO some of these need usize
extern "C" fn malloc(size: u32) -> *u8;
extern "C" fn realloc(ptr: *u8, new_size: u32) -> *u8;
extern "C" fn memcpy(dest: *u8, src: *u8, n: u32) -> *u8;
extern "C" fn free(ptr: *u8);
extern "C" fn exit(status: u32);
extern "C" fn sleep(seconds: u32) -> u32;
extern "C" fn putchar (c: u32) -> i32;
extern "C" fn puts(s: *i8) -> i32;
extern "C" fn random() -> u32;
extern "C" fn SDL_Init(flags: u32) -> i32;
extern "C" fn SDL_CreateWindow(title: *u8, x: u32, y: u32, w: u32, h: u32, flags: u32) -> *SDL_Window;
extern "C" fn SDL_PollEvent(ev: *u32) -> u32;
extern "C" fn SDL_GetWindowSurface(window: *u8) -> *SDL_Surface;
extern "C" fn SDL_UpdateWindowSurface(window: *u8) -> u32;
extern "C" fn SDL_GetError() -> *u8;
extern "C" fn SDL_ClearError();
extern "C" fn SDL_CreateRenderer(window: *SDL_Window, index: i32, flags: u32) -> *SDL_Renderer;
extern "C" fn SDL_RenderCopy(renderer: *SDL_Renderer, texture: *SDL_Texture, srcrect: *SDL_Rect, dstrect: *SDL_Rect) -> u32;
extern "C" fn SDL_CreateTextureFromSurface(renderer: *SDL_Renderer, surface: *SDL_Surface) -> *SDL_Texture;
extern "C" fn SDL_FreeSurface(surface: *SDL_Surface);
extern "C" fn SDL_DestroyTexture(texture: *SDL_Texture);
extern "C" fn SDL_RenderPresent(renderer: *SDL_Renderer);
extern "C" fn SDL_Delay(ms: u32);
extern "C" fn SDL_RenderClear(renderer: *SDL_Renderer) -> u32;
extern "C" fn SDL_QueryTexture(texture: *SDL_Texture, format: *u32, access: *u32, w: *u32, h: *u32) -> u32;
extern "C" fn IMG_Init(flags: i32) -> i32;
extern "C" fn IMG_Load(file: *u8) -> *SDL_Surface;
extern "C" fn TTF_Init() -> u32;
extern "C" fn TTF_OpenFont(file: *u8, ptsize: u32) -> *TTF_Font;
extern "C" fn TTF_RenderText_Solid(font: *TTF_Font, text: *u8, fg: SDL_Color) -> *SDL_Surface;
extern "C" fn Mix_OpenAudio(frequency: u32, format: u16, channels: u32, chunksize: u32) -> u32;
extern "C" fn Mix_LoadMUS(file: *u8) -> *Mix_Music;
extern "C" fn Mix_LoadWAV(file: *u8) -> *Mix_Chunk;
extern "C" fn Mix_PlayChannel(channel: u32, chunk: *Mix_Chunk, loops: u32) -> u32;

// --------------------------------------------------------------------------------------------------------------------
// END BINDINGS
// --------------------------------------------------------------------------------------------------------------------

fn abort(msg: &u8) {
    puts(msg);
    exit(1);
}

fn rand_range(lower: u32, upper: u32) -> u32 {
    return random() % (upper + 1 - lower) + lower;
}

fn itoa(n: u32, buf: *u8) {
    if n == 0 {
        *buf = '0';
        buf += 1;
        *buf = 0;
    } else {
        let divisor: u32 = 1000000000;

        while n / divisor == 0 {
            divisor /= 10;
        }

        divisor *= 10;

        while divisor != 1 {
            *buf = ((n % divisor) / divisor / 10 + 48);
            divisor /= 10;
            buf += 1;
        }

        *buf = 0;
    }
}

struct Pos {
    x: i32;
    y: i32;
}

struct Sprite {
    tile_x: u32;
    tile_y: u32;
    tile_w: u32;
    tile_h: u32;
}

struct SpriteSheet {
    tileSize: u32;
    tex: *SDL_Texture;
}

impl SpriteSheet {
    fn new(tileSize: u32, tex: *SDL_Texture) -> Self {
        let spritesheet: SpriteSheet;
        spritesheet.tileSize = tileSize;
        spritesheet.tex = tex;
        return spritesheet;
    }

    fn drawTile(&self, renderer: *SDL_Renderer, sprite: &Sprite, dstRect: &SDL_Rect) {
        let srcRect: SDL_Rect = SDL_Rect {
            x: sprite.tile_x * self.tileSize,
            y: sprite.tile_y * self.tileSize,
            w: sprite.tile_w * self.tileSize,
            h: sprite.tile_h * self.tileSize
        };

        if SDL_RenderCopy(renderer, self.tex, &srcRect, dstRect) < 0 {
            puts(SDL_GetError());
        }
    }
}

struct InputState {
    up: bool;
    down: bool;
    left: bool;
    right: bool;
    shoot: bool;
}

impl InputState {
    fn new() -> Self {
        let input: Self;
        input.up = false;
        input.down = false;
        input.left = false;
        input.right = false;
        input.shoot = false;
        return input;
    }
}

struct Player {
    pos: Pos;
    sprite: Sprite;
    w: u32;
    h: u32;
    speed: u32;
    animState: u32;
    animTicksLeft: u32;
    shootCooldown: u32;
    shootTicksLeft: u32;
}

struct Bullet {
    is_alive: bool;
    pos: Pos;
}

struct Enemy {
    is_alive: bool;
    pos: Pos;
}

struct Particle {
    is_alive: bool;
    pos: Pos;
    speed: u32;
}

struct EntityList<T> {
    len: u32;
    cap: u32;
    ptr: *T;
}

// TODO iter()
impl EntityList<T> {
    fn init(&self, cap: u32) {
        self.len = 0;
        self.cap = cap;
        self.ptr = malloc(sizeof(T) * cap);
    }

    fn get(&self, id: u32) -> &T {
        if self.ptr != nullptr && id < self.len {
            return self.ptr + id;
        }
        return nullptr;
    }

    fn kill(&self, id: u32) {
        self.get(id).is_alive = 0;
    }

    fn spawn(&self, entity: *T) -> u32 {
        let idx: u32 = 0;
        if self.len < self.cap {
            idx = self.len;
            self.len += 1;
        } else {
            let run: bool = true; // TODO we have no 'break' yet lmao
            while idx < self.len && run {
                let b: &T = self.get(idx);
                if !b.is_alive {
                    run = false;
                } else {
                    idx += 1;
                }
            }
        }
        
        if self.ptr != nullptr && idx < self.len {
            memcpy(self.ptr + idx, entity, sizeof(T));
        }

        return idx;
    }

    fn despawn(&self, id: u32) {
        self.get(id).is_alive = false;
    }
}

struct GameContext {
    window_w: u32;
    window_h: u32;
    renderer: *SDL_Renderer;
    spritesheet: SpriteSheet;
    font: *TTF_Font;
    sfx_pew: *Mix_Chunk;
    sfx_explosion: *Mix_Chunk;
    score: u32;
    enemies: EntityList<Enemy>;
    bullets: EntityList<Bullet>;
    particles: EntityList<Particle>;
    enemy_spawn_cooldown: u32;
    enemy_spawn_ticks_left: u32;
    particle_spawn_cooldown: u32;
    particle_spawn_ticks_left: u32;
}

const BULLET_SPEED: u32 = 6;

// TODO do not treat this as a generic impl
// impl Foo<u32> {}
// generics for the impl should be the ones following the keyword 'impl', the struct ones should be type args

fn main(argc: u32) -> u32 {
    // TODO spread op
    let ctx: GameContext = GameContext {window_w: 400, window_h: 600, score: 0};

    if SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0 {
        abort(SDL_GetError());
    }

    if IMG_Init(2) < 0 {
        abort(SDL_GetError());
    }

    if TTF_Init() < 0 {
        abort(SDL_GetError());
    }

    if Mix_OpenAudio(44100, 32784 as u16, 2, 2048) < 0 {
        abort(SDL_GetError());
    }

    let window: *SDL_Window = SDL_CreateWindow("schut", 800, 400, ctx.window_w, ctx.window_h, 4);
    if window == nullptr {
        abort(SDL_GetError());
    }

    ctx.renderer = SDL_CreateRenderer(window, -1, 1);
    if ctx.renderer == nullptr {
        abort(SDL_GetError());
    }

    let surface: *SDL_Surface = SDL_GetWindowSurface(window);
    if surface == nullptr {
        abort(SDL_GetError());
    }

    let img: *SDL_Surface = IMG_Load("spritesheet.png");
    if img == nullptr {
        abort(SDL_GetError());
    }

    let texSpritesheet: *SDL_Texture = SDL_CreateTextureFromSurface(ctx.renderer, img);
    SDL_FreeSurface(img);
    if texSpritesheet == nullptr {
        abort(SDL_GetError());
    }
    
    ctx.spritesheet = SpriteSheet::new(16, texSpritesheet);

    ctx.font = TTF_OpenFont("arcade_n.ttf", 16);
    if ctx.font == nullptr {
        abort(SDL_GetError());
    }

    ctx.sfx_pew = Mix_LoadWAV("pew.wav");
    if ctx.sfx_pew == nullptr {
        abort(SDL_GetError());
    }

    ctx.sfx_explosion = Mix_LoadWAV("explosion.wav");
    if ctx.sfx_explosion == nullptr {
        abort(SDL_GetError());
    }

    let player: Player = Player {
        sprite: Sprite {tile_x: 0, tile_y: 0, tile_w: 1, tile_h: 1},
        w: 32,
        h: 32,
        speed: 3,
        animState: 0,
        animTicksLeft: 30,
        pos: Pos {x: 200, y: ctx.window_h - 32},
        shootCooldown: 45,
        shootTicksLeft: 0
    };

    ctx.bullets.init(100);
    ctx.enemies.init(100);
    ctx.particles.init(100);

    ctx.enemy_spawn_cooldown = 60;
    ctx.enemy_spawn_ticks_left = 0;

    ctx.particle_spawn_cooldown = 10;
    ctx.particle_spawn_ticks_left = 0;

    let ev: SDL_Event;
    let kb_event: SDL_KeyboardEvent;

    let input: InputState = InputState::new();

    while true {
        while SDL_PollEvent(&ev) == 1 {
            if ev.type == SDL_QUIT {
                exit(0);
            }

            if ev.type == SDL_KEYDOWN {
                kb_event = ev;
                if kb_event.keysym.scancode == SDL_SCANCODE_ESCAPE {
                    exit(0);
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_W {
                    input.up = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_A {
                    input.left = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_S {
                    input.down = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_D {
                    input.right = true;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_SPACE {
                    input.shoot = true;
                }
            }

            if ev.type == SDL_KEYUP {
                kb_event = ev;
                if kb_event.keysym.scancode == SDL_SCANCODE_W {
                    input.up = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_A {
                    input.left = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_S {
                    input.down = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_D {
                    input.right = false;
                }
                if kb_event.keysym.scancode == SDL_SCANCODE_SPACE {
                    input.shoot = false;
                }
            }
        }
        
        if input.up && player.pos.y > 0 {
            player.pos.y -= player.speed;
        }
        if input.left && player.pos.x > 0 {
            player.pos.x -= player.speed;
        }
        if input.down && player.pos.y < (ctx.window_h - player.h) {
            player.pos.y += player.speed;
        }
        if input.right && player.pos.x < (ctx.window_w - player.w) {
            player.pos.x += player.speed;
        }
        
        if player.shootTicksLeft > 0 {
            player.shootTicksLeft -= 1;
        } else {
            if input.shoot {
                let bullet: Bullet = Bullet {is_alive: true, pos: Pos {x: player.pos.x, y: player.pos.y - 20}};
                ctx.bullets.spawn(&bullet);
                player.shootTicksLeft = player.shootCooldown;
                Mix_PlayChannel(-1, ctx.sfx_pew, 0);
            } 
        }

        if ctx.enemy_spawn_ticks_left == 0 {
            let margin_x: u32 = 10;
            let x: u32 = rand_range(margin_x, ctx.window_w - 32 - margin_x);
            let enemy: Enemy = Enemy {is_alive: true, pos: Pos {x: x, y: 0}};
            ctx.enemies.spawn(&enemy);
            ctx.enemy_spawn_ticks_left = rand_range(ctx.enemy_spawn_cooldown - 20, ctx.enemy_spawn_cooldown + 20);
        } else {
            ctx.enemy_spawn_ticks_left -= 1;
        }

        if ctx.particle_spawn_ticks_left == 0 {
            let x: u32 = rand_range(0, ctx.window_w - 32);
            let particle: Particle = Particle {is_alive: true, pos: Pos {x: x, y: 0}, speed: rand_range(4, 8)};
            // ctx.particles.spawn(&enemy); how the fuck is 'enemy' in scope? -- impl proper block scope
            ctx.particles.spawn(&particle);
            ctx.particle_spawn_ticks_left = ctx.particle_spawn_cooldown;
        } else {
            ctx.particle_spawn_ticks_left -= 1;
        }

        SDL_RenderClear(ctx.renderer);

        if player.animTicksLeft == 0 {
            if player.animState == 0 {
                player.animState = 1;
                player.sprite.tile_x = 1;
            } else {
                player.animState = 0;
                player.sprite.tile_x = 0;
            }
            player.animTicksLeft = 30; 
        } else {
            player.animTicksLeft -= 1;
        }

        ctx.spritesheet.drawTile(
            ctx.renderer,
            &player.sprite,
            &SDL_Rect {x: player.pos.x, y: player.pos.y, w: player.w, h: player.h}
        );

        update_particles(&ctx);
        update_enemies(&ctx);
        update_bullets(&ctx);

        let white: SDL_Color = SDL_Color {r: 255, g: 255, b: 255, a: 255};

        // Render score
        let buf: [u8; 16];
        let pBuf: *u8 = &buf;
        itoa(ctx.score, pBuf);
        let surface_text: *SDL_Surface = TTF_RenderText_Solid(ctx.font, pBuf, white);
        let tex_score: *SDL_Texture = SDL_CreateTextureFromSurface(ctx.renderer, surface_text);
        let w: u32;
        let h: u32;
        SDL_QueryTexture(tex_score, nullptr, nullptr, &w, &h);
        let rect: SDL_Rect = SDL_Rect {x: ctx.window_w / 2 - w / 2, y: 10, w: w, h: h};
        SDL_RenderCopy(ctx.renderer, tex_score, nullptr, &rect);
        SDL_FreeSurface(surface_text);
        SDL_DestroyTexture(tex_score);

        SDL_RenderPresent(ctx.renderer);
        SDL_Delay(16);
    }

    return 0;
}

fn aabb(a: &SDL_Rect, b: &SDL_Rect) -> bool {
    return
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y;
}

// TODO these should take a &Ctx
fn update_enemies(ctx: &GameContext) {
    let sprite: Sprite = Sprite {tile_x: 3, tile_y: 0, tile_w: 1, tile_h: 1};

    let i: u32 = 0;
    while i < ctx.enemies.len {
        let enemy: &Enemy = ctx.enemies.get(i);
        if enemy.is_alive {
            // Check bullet collisions
            let bullet_idx: u32 = 0;
            while bullet_idx < ctx.bullets.len {
                let bullet: &Bullet = ctx.bullets.get(bullet_idx);
                if bullet.is_alive {  
                    if aabb(
                        &SDL_Rect {x: enemy.pos.x, y: enemy.pos.y, w: 32, h: 32},
                        &SDL_Rect {x: bullet.pos.x, y: bullet.pos.y, w: 16, h: 16})
                    {
                        enemy.is_alive = false;
                        bullet.is_alive = false;

                        Mix_PlayChannel(-1, ctx.sfx_explosion, 0);
                        ctx.score += 10;
                    }
                }

                bullet_idx += 1;
            }

            enemy.pos.y += 2;
            if enemy.pos.y > ctx.window_h {
                enemy.is_alive = false;
            }

            // Render
            ctx.spritesheet.drawTile(ctx.renderer, &sprite, &SDL_Rect {x: enemy.pos.x, y: enemy.pos.y, w: 32, h: 32});
        }
        i += 1;
    }
}

fn update_bullets(ctx: &GameContext) {
    let sprite: Sprite = Sprite {tile_x: 2, tile_y: 0, tile_w: 1, tile_h: 1};

    let i: u32 = 0;
    while i < ctx.bullets.len {
        let bullet: &Bullet = ctx.bullets.get(i);
        if bullet.is_alive {
            ctx.spritesheet.drawTile(ctx.renderer, &sprite, &SDL_Rect {x: bullet.pos.x, y: bullet.pos.y, w: 32, h: 32});

            bullet.pos.y -= BULLET_SPEED;
            if bullet.pos.y < 0 {
                ctx.bullets.despawn(i);
            }
        }
        i += 1;
    }
}

fn update_particles(ctx: &GameContext) {
    let i: u32 = 0;
    while i < ctx.particles.len {
        let particle: &Particle = ctx.particles.get(i);
        if particle.is_alive {
            ctx.spritesheet.drawTile(
                ctx.renderer,
                &Sprite {tile_x: 4, tile_y: 0, tile_w: 1, tile_h: 1},
                &SDL_Rect {x: particle.pos.x, y: particle.pos.y, w: 16, h: 16}
            );

            particle.pos.y += particle.speed;
            if particle.pos.y > ctx.window_h {
                ctx.particles.despawn(i);
            }
        }
        i += 1;
    }
}