struct SDL_Event {
    type: u32;
    // TODO the rest, once we have unions
    _padding: [u8; 56];
}

struct SDL_Rect {
    x: u32;
    y: u32;
    w: u32;
    h: u32;
}

struct SDL_Window {}
struct SDL_Renderer {}
struct SDL_Surface {}
struct SDL_Texture {}

// TODO some of these need usize
extern "C" fn malloc(size: u64) -> *void;
extern "C" fn realloc(ptr: *void, new_size: u64) -> *void;
extern "C" fn memcpy(dest: *void, src: *void, n: u64) -> *void;
extern "C" fn exit(status: u32) -> void;
extern "C" fn sleep(seconds: u32) -> u32;
extern "C" fn puts(s: *i8) -> i32;
extern "C" fn SDL_Init(flags: u32) -> i32;
extern "C" fn SDL_CreateWindow(title: *u8, x: u32, y: u32, w: u32, h: u32, flags: u32) -> *SDL_Window;
extern "C" fn SDL_PollEvent(ev: *u32) -> u32;
extern "C" fn SDL_GetWindowSurface(window: *u8) -> *SDL_Surface;
extern "C" fn SDL_UpdateWindowSurface(window: *u8) -> u32;
extern "C" fn SDL_GetError() -> *u8;
extern "C" fn SDL_ClearError() -> void;
extern "C" fn SDL_CreateRenderer(window: *SDL_Window, index: i32, flags: u32) -> *SDL_Renderer;
extern "C" fn SDL_RenderCopy(renderer: *SDL_Renderer, texture: *SDL_Texture, srcrect: *SDL_Rect, dstrect: *SDL_Rect) -> u32;
extern "C" fn SDL_CreateTextureFromSurface(renderer: *SDL_Renderer, surface: *SDL_Surface) -> *SDL_Texture;
extern "C" fn SDL_FreeSurface(surface: *SDL_Surface) -> void;
extern "C" fn SDL_RenderPresent(renderer: *SDL_Renderer) -> void;
extern "C" fn SDL_Delay(ms: u32) -> void;
extern "C" fn SDL_RenderClear(renderer: *SDL_Renderer) -> u32;
extern "C" fn IMG_Init(flags: i32) -> i32;
extern "C" fn IMG_Load(file: *u8) -> *SDL_Surface;

fn main(argc: u32) -> u32 {
    let title: [u8; 5] = "game";
    let pTitle: *u8 = &title;

    let texPath: [u8; 9] = "doll.jpg";
    let pTexPath: *u8 = &texPath;

    if SDL_Init(32) < 0 {
        puts(SDL_GetError());
        return 1;
    }

    if IMG_Init(1) < 0 {
        puts(SDL_GetError());
        return 1;
    }

    let window: *SDL_Window = SDL_CreateWindow(pTitle, 0, 0, 400, 400, 4);
    if window == nullptr {
        puts(SDL_GetError());
    }

    let renderer: *SDL_Renderer = SDL_CreateRenderer(window, -1, 1);
    if renderer == nullptr {
        puts(SDL_GetError());
    }

    let surface: *SDL_Surface = SDL_GetWindowSurface(window);
    if surface == nullptr {
        puts(SDL_GetError());
    }

    let img: *SDL_Surface = IMG_Load(pTexPath);
    if img == nullptr {
        puts(SDL_GetError());
    }

    let tex: *SDL_Texture = SDL_CreateTextureFromSurface(renderer, img);
    if tex == nullptr {
        puts(SDL_GetError());
    }

    SDL_FreeSurface(img);

    let rect: *SDL_Rect = malloc(16);
    (*rect).x = 200;
    (*rect).y = 100;
    (*rect).w = 100;
    (*rect).h = 100;

    let x_speed: u32 = 1;
    let y_speed: u32 = 1;
    
    let ev: SDL_Event;
    while true {
        while SDL_PollEvent(&ev) == 1 {
            if ev.type == 256 {
                exit(1);
            }
        }

        (*rect).x = (*rect).x + x_speed;
        if (*rect).x == 0 {
            x_speed = 1;
        }
        if (*rect).x == 300 {
            x_speed = -1;
        }
        
        (*rect).y = (*rect).y + y_speed;
        if (*rect).y == 0 {
            y_speed = 1;
        }
        if (*rect).y == 300 {
            y_speed = -1;
        }

        SDL_RenderClear(renderer);

        if SDL_RenderCopy(renderer, tex, 0, rect) < 0 {
            puts(SDL_GetError());
        }

        SDL_RenderPresent(renderer);
        SDL_Delay(8);
    }

    return 0;
}